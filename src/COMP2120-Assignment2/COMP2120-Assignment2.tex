% !TEX program = latexmk
% !TEX options = --shell-escape -synctex=1 -interaction=nonstopmode -file-line-error -pdf -cd -outdir=. ./COMP2120-Assignment2.tex

\documentclass[answers]{exam}
\input{packages.tex}
\input{preamble.tex}

\begin{document}

\begin{center}
    \textbf
    {\Large{COMP2120 Computer Organisation} \\
    \large{24/25 Semester 2} \\
    \large{Assignment 2}}
\end{center}

\begin{questions}

    \question Consider a simple 32-bit processor with the data path as shown in fig. 1. The
        processor has 32 general purpose registers. There are 3 buses, S1-bus, S2-bus and D-bus
        connecting the registers for data movement. The register files has 2 read ports and 1
        write port (i.e. it can perform 2 read and 1 write at the same time).

    \begin{figure}[H]
        \centering
        \includegraphics[width=0.7\textwidth]{figure.pdf}
        \caption{A simplified CPU}
    \end{figure}

    The processor has instructions which specifies 3 operands explicitly (namely, 2 source
    and 1 destination operands). The leftmost byte of the instruction represents the oper-
    ation to be performed, such as \texttt{ADD}, \texttt{SUB} etc. For arithmetic and logic operations, the
    operands must be in registers. Hence the 3 bytes will give the addresses of operands in
    the register file. There will be a direct path connecting these 3 bytes in the \texttt{IR}
    (Instruction Register) to the address of the register file, so that when you perform read/write
    on register file, the register specified in these bytes will be accessed.
    
    If the instruction is \texttt{LOAD} or \texttt{STORE} to load a word from memory to register, and
    vice versa, the source operand (\texttt{LOAD}) or destination operand (\texttt{STORE}) refer to a memory
    address. How to find this address is specified by Addressing Mode. In this machine, for
    simiplicity, the memory operand byte (source/destination) will always be \texttt{1111 1111} (or
    in hex \texttt{0xff}), which means that the actual 32-bit memory address will be given in the
    word following the instruction (see example program below).
    
    The \texttt{ALU} has the following operations: \texttt{ADD}, \texttt{SUB}, bitwise \texttt{AND}, \texttt{OR}, and \texttt{NOT}. For
    operations with only one operand (e.g. \texttt{NOT}), source operand 1 is used, and source
    operand 2 is empty.
    
    Finally, there is a branch instruction, which performs conditional or unconditional
    branch as specified in the cc field of the instruction. The branch address is specified in
    the word following the instruction, the same as in \texttt{LOAD}/\texttt{STORE} instruction.

    \section*{Instruction Format}

    \subsection*{Arithmetic/Logic Instruction}

    The instruction format of the machine (except \texttt{LOAD}/\texttt{STORE}/\texttt{BRANCH}):
    \begin{center}
        \begin{tabular}{|c|c|c|c|}
            \hline
            Opcode & Source Operand 1 & Source Operand 2 & Destination Operand \\
            \hline
        \end{tabular}
    \end{center}
    The instructions can be categorized into the following types:
    \begin{itemize}
        \item \textbf{Arithmetic Operations}
        \begin{verbatim}
ADD     R1, R2, R3  ; R3 <- R1 + R2
SUB     R1, R2, R3  ; R3 <- R1 - R2
        \end{verbatim}
        \item \textbf{Logic Operations}
        \begin{verbatim}
AND     R1, R2, R3  ; R3 <- R1 AND R2
OR      R1, R2, R3  ; R3 <- R1 OR R2
NOT     R1, R3      ; R3 <- NOT R1
        \end{verbatim}
        \item \textbf{Data Movement Instruction}
        \begin{verbatim}
MOV     R1, R3      ; R3 <- R1
        \end{verbatim}
    \end{itemize}
    Note that in the \texttt{NOT} and \texttt{MOV} operations, source operand 2 field is not used and will be set as \texttt{0000 0000}.

    \subsection*{Load/Store Instruction}

    Moving data from Memory to registers and vice versa.
    \begin{verbatim}
LD      A, R3   ; R3 <- A, A is in memory
ST      R3, A   ; A <- R3, A is in memory
    \end{verbatim}

    Load instruction:
    \begin{center}
        \begin{tabular}{|c|c|c|c|}
            \hline
            Opcode (Load) & 00000000 & Addressing Mode & Destination Operand \\
            \hline
        \end{tabular}
    \end{center}
    Store instruction:
    \begin{center}
        \begin{tabular}{|c|c|c|c|}
            \hline
            Opcode (Store) & Source Operand & Addressing Mode & 00000000 \\
            \hline
        \end{tabular}
    \end{center}
    where the addressing mode (how to find the target address) is specified in byte 2 of the
    instruction. In this machine, only one addressing mode is used, where the target address
    is given by the word following the \texttt{LOAD} or \texttt{STORE} instruction (Absolute Addressing). This
    is specified as \texttt{11111111} in that byte.

    \subsection*{Control Instruction}

    Control flow is by using \texttt{BRANCH} instruction. There are two types of branch instruction
    â€” conditional and unconditional Branch. Branch Instruction Format:
    \begin{center}
        \begin{tabular}{|c|c|c|c|}
            \hline
            Opcode (Branch) & Condition Code (cc) & Addressing Mode & 00000000 \\
            \hline
        \end{tabular}
    \end{center}

    Conditional branch is based on the result of previous ALU operation, which is store in
    a flag register. In this machine, we only use a \texttt{ZERO} flag, which will be set to 1 if the
    ALU operation results in 0, and set to 0 otherwise. The target address is specified in
    the same way as in memory operation. Similarly, the byte of Addressing Mode is set to
    \texttt{11111111}.
    The condition code is specified as
    \begin{center}
        \begin{tabular}{|c|c|c|}
            \hline
            Condition Code (cc) & Instruction & Description \\
            \hline
            \texttt{00000000} & \texttt{BR} & Unconditional Branch, always goto \\ \hline
            \texttt{00000001} & \texttt{BZ} & Branch if \texttt{ZERO} flag is set \\ \hline
            \texttt{00000010} & \texttt{BNZ} & Branch if \texttt{ZERO} flag is not set \\ \hline
        \end{tabular}
    \end{center}

    \subsection*{Halt Instruction}

    The \texttt{HLT} instruction is used to stop the program. The other 3 bytes are all 0.

    \subsection*{Opcodes}

    \begin{center}
        \begin{tabular}{|c|c|c|c|c|c|}
            \hline
            Instruction & Opcode & Instruction & Opcode & Instruction & Opcode \\
            \hline
            \texttt{ADD} & \texttt{00000000} & \texttt{OR} & \texttt{00000100} & \texttt{Bcc} & \texttt{00001000} \\ \hline
            \texttt{SUB} & \texttt{00000001} & \texttt{MOV} & \texttt{00000101} & \texttt{HLT} & \texttt{00001001} \\ \hline
            \texttt{NOT} & \texttt{00000010} & \texttt{LD} & \texttt{00000110} & & \\ \hline
            \texttt{AND} & \texttt{00000011} & \texttt{ST} & \texttt{00000111} & & \\ \hline
        \end{tabular}
    \end{center}

    \section*{Part I: Example Program}

    The simulator program is given in \texttt{sim.py}. The code for the \texttt{SUB} and \texttt{ST} instruction is
    missing. Study the simulator code carefully, and complete the missing part.

    \begin{quotation}
        \textit{
            \textbf{Author's Note:}
            The code files are also provided on the website. Click on the ``Download Attachments'' button to download.
        }
    \end{quotation}

    \begin{solution}
        \textit{(The missing parts in the example program:)}

        Note that the comments are included for explanation only, and are not required in your submission.
        \begin{minted}[firstnumber=220]{python3}
def set_SUB():
    # Fill in the code for SUB instruction here
    Signal["calc_addr"] = 0         # Disable address calculation (not needed)
    Signal["branch"] = 0            # This is not a branch instruction
    Signal["read_RF_port_1"] = 1    # Enable read from RF1 (source operand 1)
    Signal["read_RF_port_2"] = 1    # Enable read from RF2 (source operand 2)
    Signal["write_RF"] = 1          # Enable writing to register file (destination operand)
    Signal["src_of_S1"] = "RFOUT1"  # Connect S1-bus source to register file output port 1
    Signal["dst_of_S1"] = "A"       # Route S1-bus destination to ALU input A
    Signal["src_of_S2"] = "RFOUT2"  # Connect S2-bus source to register file output port 2
    Signal["dst_of_S2"] = "B"       # Route S2-bus destination to ALU input B
    Signal["src_of_D"] = "C"        # Connect D-bus source to ALU output C
    Signal["dst_of_D"] = "RFIN"     # Route D-bus destination to register file input
    Signal["doalu"] = 1             # Enable ALU operation
    Signal["ALU_func"] = "OP_SUB"   # Set ALU function to subtraction operation
    Signal["move_via_S1"] = 1       # Enable data movement through S1-bus
    Signal["move_via_S2"] = 1       # Enable data movement through S2-bus
    Signal["move_via_D"] = 1        # Enable data movement through D-bus
    Signal["read_memory"] = 0       # Disable memory read (not a load instruction)
    Signal["write_memory"] = 0      # Disable memory write (not a store instruction)
    Signal["dohalt"] = 0            # Do not halt the processor
            \end{minted}

            \begin{minted}[firstnumber=347]{python3}
def set_ST():
    # Fill in the code for ST instruction here
    Signal["calc_addr"] = 1         # Enable address calculation (needed for 0xFF mode)
    Signal["branch"] = 0            # This is not a branch instruction
    Signal["read_RF_port_1"] = 1    # Enable read from RF1 (source operand - register)
    Signal["read_RF_port_2"] = 0    # Disable read from RF2 (not needed for store)
    Signal["write_RF"] = 0          # Disable writing to register file (storing to memory)
    Signal["src_of_S1"] = "RFOUT1"  # Connect S1-bus source to register file output port 1
    Signal["dst_of_S1"] = "A"       # Route S1-bus destination to ALU input A
    Signal["src_of_S2"] = ""        # S2-bus source not needed (no second operand)
    Signal["dst_of_S2"] = ""        # S2-bus destination not needed (no second operand)
    Signal["src_of_D"] = "C"        # Connect D-bus source to ALU output C
    Signal["dst_of_D"] = "MBR"      # Route D-bus destination to Memory Buffer Register
    Signal["doalu"] = 1             # Enable ALU operation
    Signal["ALU_func"] = "OP_COPY"  # Set ALU function to copy operation (pass data through)
    Signal["move_via_S1"] = 1       # Enable data movement through S1-bus
    Signal["move_via_S2"] = 0       # Disable data movement through S2-bus (not used)
    Signal["move_via_D"] = 1        # Enable data movement through D-bus
    Signal["read_memory"] = 0       # Disable memory read (this is a store, not load)
    Signal["write_memory"] = 1      # Enable memory write (store data to memory)
    Signal["dohalt"] = 0            # Do not halt the processor
        \end{minted}
    \end{solution}

    Running the simulator program:
    \vspace*{-0.2cm}\begin{verbatim}
        [python3] sim.py [-d] prog
    \end{verbatim}\vspace*{-0.6cm}
    If \texttt{-d} option is specified, the program will print out debug information.
    The simulator obtains input program from the file \texttt{prog}.
    Test you simulator with the following simple program:
    \begin{verbatim}
            LD      P0,R4                   0000:   0600ff04 0000003c
            LD      P1,R1                   0008:   0600ff01 00000040
            MOV     R1,R2                   0010:   05010002
            LD      P2,R3                   0014:   0600ff03 00000044
        L:  ADD     R4,R1,R4                001C:   00040104
            ADD     R1,R2,R1                0020:   00010201
            SUB     R3,R1,R5                0024:   01010305
            BNZ     L                       0028:   0802ff00 0000001c
            ST      R4,P                    0030:   0704ff00 00000048
            HLT                             0038:   09000000
        P0: .WORD   0                       003C:   00000000
        P1: .WORD   1                       0040:   00000001
        P2: .WORD   A                       0044:   0000000a
        P:  .WORD                           0048:   00000000
    \end{verbatim}
    What does this program do?

    \begin{solution}
        The program computes the sum of integers from 1 to 9.
    \end{solution}
    
\end{questions}

\end{document}